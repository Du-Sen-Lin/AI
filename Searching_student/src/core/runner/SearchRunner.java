package core.runner;import core.astar.AStar;import core.astar.Node;import core.problem.Problem;import g07.problem.blocks.BlocksProblem;import g07.problem.blocks.BlocksState;import g07.problem.npuzzle.NpuzzleProblem;import g07.problem.npuzzle.NpuzzleState;import xu.problem.mc.McProblem;import java.util.ArrayList;import java.util.Scanner;import java.util.Stack;public class SearchRunner {	public SearchRunner() {		// TODO Auto-generated constructor stub	}	public static void main(String[] args) {		testNPuzzle();		//testBlocks();	}	public static void testNPuzzle() {		//初始状态		//int[] status = {8, 6, 7, 2, 5, 4, 3, 0, 1};  //0.047s   150ms左右		//int[] status = {6, 4, 7, 8, 5, 0, 3, 2, 1};   //0.047s  150ms左右		//int[] status = {0, 2, 3, 4, 6, 1, 7, 5,8};       // int[] status = {8, 13, 0, 6, 1, 15, 9, 14, 3, 4, 5, 11, 7, 2, 10, 12};   //老师:0.304s     1672 ms	    //	int[] status = {2,9,5,11,8,3,4,14,7,10,1,12,0,15,6,13}; //3.652s       int status[] = {4,7,0,9,12,10,11,8,14,6,15,1,2,5,3,13};   //12.367s        //int status = {12,10,3,2,0,7,14,9,1,15,5,6,8,4,13,11};  //75.458s        //int[] status = {15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0};   //l分钟      //  int[] goal = {1, 2, 3, 4, 5, 6, 7, 8, 0};        int[] goal = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,0};		//Problem npuzzle = new NpuzzleProblem(3, new NpuzzleState(3,status), new NpuzzleState(3,goal));       Problem npuzzle = new NpuzzleProblem(4, new NpuzzleState(4,status), new NpuzzleState(4,goal));		//获取初始状态并打印出来//		NpuzzleState initial = (NpuzzleState) npuzzle.getInitialState();//		npuzzle.getInitialState().draw();		Stack<Node> stack = new Stack<Node>();		long time = System.currentTimeMillis();		AStar a = new AStar(npuzzle);		Node node = a.Search();		System.out.println("Time: " + (System.currentTimeMillis() - time) + "ms");		while (node!=null){			stack.push(node);			node = node.getParent();		}		//stack.peek() 查看栈顶对象而不移除他		while (!stack.isEmpty()&&stack.peek()!=null){				if(stack.peek().getAction()!=null) {					stack.peek().getAction().draw(); //画出Action				}				stack.peek().draw();     //画出State				stack.pop();		}	}    public static void testBlocks() {        @SuppressWarnings("resource")        Scanner reader = new Scanner(System.in);        //读入块数        int size;        System.out.println("Please enter the number of monochrome blocks:");        size = reader.nextInt();        if (size < 2)            return;        int capacity;        System.out.println("Please enter the walking method.");        System.out.println("Note: Input 1 can jump cards into spaces at most 2 other cards   -----  Input 2 can jump cards into spaces at most (n+1)/2 other cards into spaces.");        capacity = reader.nextInt();        if(capacity==1)            capacity=2;        else            capacity=(size+1)/2;        System.out.println("Please enter the initial chess game (0 is blank-1 is white-1 is black, there are spaces in the middle))");        //initStatus        int[] ini=new int[size*2+1];        for(int i=0;i<=2*size;i++){            ini[i]=reader.nextInt();        }        Problem.setZobrist(2, 2*size+1);        BlocksState initialState= new BlocksState(size,ini,Problem.zobrist);        Problem blocks=new BlocksProblem(initialState,size,capacity);        long startTime=System.currentTimeMillis();; //获取开始时间        AStar a = new AStar(blocks);        Node node = a.Search();        long endTime=System.currentTimeMillis();; //获取结束时间        ArrayList<Node> nodeList = new ArrayList<Node>();//状态链表        int i=0;        nodeList.add(i++,node);        while (node.getParent() != null) {            node = node.getParent();            nodeList.add(i++,node);        }        for ( int j = i-1; j >=0; j -- ){            Node print = nodeList.get(j);            print.draw();        }        System.out.println("");        System.out.println("Time: "+(endTime-startTime)+"ms");    }	public static void testMC() {		//		Problem mc = new McProblem(3, 2);		AStar a = new AStar(mc);		Node node = a.Search();		node.getState();		node.draw();		node.getAction().draw();		while (node.getParent() != null) {			node = node.getParent();			node.draw();			if (node.getAction() != null)				node.getAction().draw();		}	}}//1 -1 -1 1 1 -1 -1 -1 -1 -1 -1 -1 1 1 1 1 1 1 0//